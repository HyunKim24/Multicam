# 클래스(class), 객체(Object)
# 객체지향프로그램(Object Oriented Programing:OOP)
# 객체:이세상에 존재하는 모든 사물(유형), 사상(무형)을 통칭
# 이런 객체를 프로그램에 구현을 한다고 한다면, 뭔가 기술하는
# 기준, 틀, 문법등등 형식이 필요하다 -> class
# class는 object의 청사진이다
####################################################################
# 클래스를 배우는 목적은 객체를 기술하기 위함
# 클래스를 생성하면 -> 객체가 생성된다(메모리상)
# 9번 표현의 요약은 class의 인스턴스는 object다
####################################################################
# 객체는 공통된 2가지 특징을 가진다.
# 속성(특성) => 사람이라는 객체를 기준 => 눈, 코, 입,..
# 행동(액션) => 사람이라는 객체를 기준 => 먹는다, 잔다, 걷는다
####################################################################
# class 문법 => OOP 프로그램을 작성하기 위함
# => 재사용성이 높아지고, oop의 특징 중에 상속을 활용하면
# 버전업이나, 기타 높은 확장성을 구사할 수 있다.
####################################################################
'''
class 클래스명(첫글자 대문자로 사용하는 것이 암묵적 룰):
    # 멤버 변수: 속성(특성)
    # 멤버 함수: 행동(액션)
    # 생성자:constructor=>함수
'''
# Person class 구성
class Person:
    # 1. 멤버 변수: 속성(특성)
    name = None
    age = 0
    # 2. 멤버 함수: 행동(액션)
    # 멤버 함수의 1번인자는 무조건 self이다.
    # self : 자기 자신 객체를 가르킴 => 타언어(this)
    def eat(self):
        print('eat() call')
    # 3. 생성자(생성함수)
    # 객체를 생성하는 역활 담당
    # 메모리에 공간을 할당, 이 주소를 반환, 참조카운트 증가(차후)
    def __init__(self,name):
        print('생성자 call')
        # 멤버 변수 사용시
        # self.변수명
        self.name = name
        # 멤버 함수를 class 내부에서 호출한다면
        self.eat()
        print('-'*10)

# # 객체 생성
# # 클래스명(인자는 생성자의 인자 형식에 맞추면 된다)
obj = Person('multi')
print(obj.name)
obj.eat()